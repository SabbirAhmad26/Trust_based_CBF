function [car,CAV_t] = main_OCBF_time(i, car, mod ,trust_thereshold, MultipleConstraints, CAV_t)

global computationTime1 dt;

L = 300;
update_class_k_function = 1;
order = zeros(length(car.table), 1);
for j = 1 : length(car.table)
    order(j) = car.table{j}(31);
end

len = length(order);
for k = 1 : 1 : len
    
    CAV_t.vel(i,car.que1{order(k)}.id(2))=car.que1{order(k)}.state(2);
    CAV_t.acc(i,car.que1{order(k)}.id(2))=car.que1{order(k)}.state(3);
    CAV_t.pos(i,car.que1{order(k)}.id(2))=car.que1{order(k)}.state(1);

    [ip, index, position] = search_for_conflictCAVS(car.table, car.que1{order(k)});
    % [ip, index, position] = search_for_conflictCAVS_trustversion(car.que1,car.table, car.que1{order(k)},MultipleConstraints,trust_thereshold);
    car.que1{order(k)}.see = Vision(car.que1,car.que1{order(k)},order(k));
    % for lane change
    % ilc = search_i_lanechange(car.que1, car.que1{k});
    
    %if lane change is disallowed
    ilc = [];
    
    tic
    if (mod == 1)
        [rt,CAV_t] = OCBF_time(i, car.que1{order(k)}, car.que1, ip, index, position, ilc, CAV_t);
        CAV_t.counter = CAV_t.counter + 1;
    elseif (mod == 2)
        rt = OC(i, car.que1{order(k)}, car.que1, ip);
    end
    record = toc;
    computationTime1 = [computationTime1, record];

    CAV_t.buffer(car.que1{order(k)}.id(2),:)=rt;
%     car.que1{order(k)}.state = rt;

    if(rt(1) <= car.que1{order(k)}.metric(end))

       [car.que1{order(k)},Score,Trust] = TrustCal(i,car.que1,car.table,car.que1{order(k)},order(k),CAV_t,trust_thereshold);      
       car.que1{order(k)}.trust(2) = car.que1{order(k)}.trust(1);
       car.que1{order(k)}.trust(1) = Trust;
       
       Data.Trust(i,car.que1{order(k)}.id(2)) = car.que1{order(k)}.trust(1);
       car.que1{order(k)}.scores = Score;
       car.que1{order(k)}.p.MarkerEdgeColor = [1-car.que1{order(k)}.trust(1) car.que1{order(k)}.trust(1) 0.5];
       car.que1{order(k)}.p.MarkerFaceColor = [1-car.que1{order(k)}.trust(1) car.que1{order(k)}.trust(1) 0.5];

    end


    if(rt(1) <= car.que1{order(k)}.metric(end))
        car.que1{order(k)}.metric(1) = car.que1{order(k)}.metric(1) + dt;
        if(car.que1{k}.state(3)>= 0)
            car.que1{order(k)}.metric(2) = fuel_consumption(car.que1{order(k)}.metric(2),rt(3),rt(2));
        else
            car.que1{order(k)}.metric(2) = car.que1{order(k)}.metric(2);
        end
        car.que1{order(k)}.metric(3) = car.que1{order(k)}.metric(3) + dt*0.5*rt(3)^2;
    else
        CAV_t.time(car.que1{order(k)}.id(2),1)=car.que1{order(k)}.metric(1);
        CAV_t.fuel(car.que1{order(k)}.id(2),1)=car.que1{order(k)}.metric(2);
        CAV_t.energy(car.que1{order(k)}.id(2),1)=car.que1{order(k)}.metric(3);
    end
            

end
for k=1:1:len
    car.que1{order(k)}.prestate = car.que1{order(k)}.state;
    car.que1{order(k)}.state=CAV_t.buffer(car.que1{order(k)}.id(2),:);
end
for k = 1:1:len
        
     if(car.que1{order(k)}.state(1) <= car.que1{order(k)}.metric(end))

      [car.que1{order(k)},Score,Trust] = TrustCal(i,car.que1,car.table,car.que1{order(k)},order(k),CAV_t,trust_thereshold);
      car.que1{order(k)}.trust(2) = car.que1{order(k)}.trust(1);
      car.que1{order(k)}.trust(1) = Trust;
      CAV_t.Trust(i,car.que1{order(k)}.id(2)) = car.que1{order(k)}.trust(1);
      car.que1{order(k)}.scores = Score;
      car.que1{order(k)}.p.MarkerEdgeColor = [1-car.que1{order(k)}.trust(1) car.que1{order(k)}.trust(1) 0.5];
      car.que1{order(k)}.p.MarkerFaceColor = [1-car.que1{order(k)}.trust(1) car.que1{order(k)}.trust(1) 0.5];
    if update_class_k_function == 1
        [ip, index, position] = search_for_conflictCAVS(car.table, car.que1{order(k)});
        if(ip ~= -1)
            car.que1{order(k)}.k_rear = car.que1{ip}.trust(1)- s3;
        end
    
        for kk = 1 : length(index)            
            deltaSafetyDistance = 0;
            if (index(kk) == -1)
                continue;
            else
            car.que1{order(k)}.k_lateral(kk) = car.que1{index(kk)}.trust(1) - s3;
            end
             
         end        
    end
      
    end



end
for k = 1:1:len
    if car.que1{order(k)}.state(1) <= L
        [ip, index, position] = search_for_conflictCAVS(car.table, car.que1{order(k)});
        one = car.que1{order(k)};
        x0 = one.state;
        if(ip ~= -1)
%           k_rear = car.que1{ip}.trust(1)- s3;
            k_rear = one.k_rear;
            phiRearEnd = one.phiRearEnd;
            CAV_t.rear_end(i,car.que1{order(k)}.id(2))=car.que1{ip}.state(1)-x0(1)-phiRearEnd*x0(2);
            CAV_t.rear_end_CBF(i,car.que1{order(k)}.id(2))= car.que1{ip}.state(2) - x0(2) -phiRearEnd*x0(3) + k_rear * (car.que1{ip}.state(1) - x0(1) - phiRearEnd * x0(2));
        end
    
        for kk = 1 : length(index)            
            deltaSafetyDistance = 0;
            if (index(kk) == -1)
                continue;
            else
            k_lateral = one.k_lateral(kk);
            phiLateral = one.phiLateral;
            vl_tk = car.que1{index(kk)}.state(2);
            xl_tk = car.que1{index(kk)}.state(1);
            d1 = car.que1{index(kk)}.metric(position(kk)+4) - xl_tk;  % distance to the merging point
            d2 = one.metric(kk+4) - x0(1); % distance to the merging point
            end
            bigPhi = phiLateral * x0(1) / L;
            CAV_t.lateral(i, one.id(2),kk) = car.que1{index(kk)}.state(1)-x0(1)-phiLateral/L*x0(1)*x0(2) - deltaSafetyDistance;
            CAV_t.lateral_CBF(i, one.id(2),kk) = car.que1{index(kk)}.state(2) - x0(2) - phiLateral*x0(2)*x0(2)/L - bigPhi*x0(3) + k_lateral * (d2 - d1 - bigPhi*x0(2) - deltaSafetyDistance);         
         end
    end



end

end